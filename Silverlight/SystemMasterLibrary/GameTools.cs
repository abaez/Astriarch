using System;
using System.Net;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Shapes;
using System.Collections.Generic;

namespace SystemMaster.Library
{
    public static class GameTools
    {
        public static Model GameModel = null;

        public static Model InitModel(List<Player> players, Player mainPlayer, int systemsToGenerate, PlanetsPerSystemOption planetsPerSystem)
        {
            GameTools.GameModel = new Model(players, mainPlayer, systemsToGenerate, planetsPerSystem);
            return GameTools.GameModel;
        }

        public static Random Randomizer = new Random();

        public delegate void PlayerDestroyed(Player player);
        public static event PlayerDestroyed OnPlayerDestroyed;
        public static event PlayerDestroyed OnPlayerDestroyedGameOver;

        public const double BATTLE_RANDOMNESS_FACTOR = 4.0;//the amount randomness (chance) when determining fleet conflict outcomes, it is the strength multiplyer where the winner is guaranteed to win

        public static string PlanetOwnerToFriendlyName(Planet p, Player planetOwner)
        {
            string owner = (p.Type == PlanetType.AsteroidBelt) ? "None" : "Natives";
            if (planetOwner != null)
                owner = planetOwner.Name;

            return owner;
        }

        public static string PlanetTypeToFriendlyName(PlanetType t)
        {
            string typeName = "Asteroid Belt";
            if (t == PlanetType.DeadPlanet)
                typeName = "Dead";
            else if (t == PlanetType.PlanetClass1)
                typeName = "Arid";//formerly "Mineral Rich"
            else if (t == PlanetType.PlanetClass2)
                typeName = "Terrestrial";

            return typeName;
        }

        public static string PlanetImprovementTypeToFriendlyName(PlanetImprovementType t)
        {
            string name = t.ToString();
            if (t == PlanetImprovementType.SpacePlatform)
                name = "Space Platform";
            return name;
        }

        public static string PlanetImprovementTypeToHelpText(PlanetImprovementType t)
        {
            string helpText = "";
            switch (t)
            {
                case PlanetImprovementType.Farm:
                    helpText = "Farms increase amount of Food produced by each farmer.";
                    break;
                case PlanetImprovementType.Mine:
                    helpText = "Mines increase the amount of Ore and Iridium produced by each miner.";
                    break;
                case PlanetImprovementType.Factory:
                    helpText = "Factories increase the production generated by each worker.\r\n" +
                               "Allows construction of Space Platforms and Destroyers.";
                    break;
                case PlanetImprovementType.Colony:
                    helpText = "Colonies increase the planet's maximum population by one.";
                    break;
                case PlanetImprovementType.SpacePlatform:
                    helpText = "Space Platforms provide planetary defense.\r\n" +
                               "Allows construction of Cruisers and Battleships.\r\n" +
                               "Advantage against: Destroyers, Disadvantage Against: Cruisers";
                    break;
            }

            return helpText;
        }

        public static string StarShipTypeToFriendlyName(StarShipType t)
        {
            string name = t.ToString();
            if (t == StarShipType.SystemDefense)
                name = "Defender";
            return name;
        }

        public static string StarShipTypeToHelpText(StarShipType t)
        {
            //here are the advantages (-> means has an advantage over):
            //defenders -> destroyers -> battleships -> cruisers -> spaceplatforms -> scouts (-> defenders)
            string helpText = "";
            switch (t)
            {
                case StarShipType.SystemDefense:
                    helpText = "Defenders protect a planet from attacking fleets but cannot move between planets.\r\n" +
                               "Advantage against: Destroyers, Disadvantage Against: Scouts";
                    break;
                case StarShipType.Scout:
                    helpText = "Scouts are the weakest ship equipped with warp drive.\r\n" +
                               "Advantage against: Defenders, Disadvantage Against: Space Platforms";
                    break;
                case StarShipType.Destroyer:
                    helpText = "Destroyers require a Factory in order to build and are twice the strength of a Scout.\r\n" +
                               "Advantage against: Battleships, Disadvantage Against: Defenders";
                    break;
                case StarShipType.Cruiser:
                    helpText = "Cruisers require a Space Platform in order to build and are twice the strength of a Destroyer.\r\n" +
                               "Advantage against: Space Platforms, Disadvantage Against: Battleships";
                    break;
                case StarShipType.Battleship:
                    helpText = "Battleships require a Space Platform in order to build and are twice the strength of a Cruiser.\r\n" +
                               "Advantage against: Cruisers, Disadvantage Against: Destroyers";
                    break;
            }

            return helpText;
        }

        /// <summary>
        /// Finishes (takes) the turns for all AI opponents and builds resources for everyone
        /// </summary>
        /// <param name="players">all players in the model</param>
        public static List<TurnEventMessage> EndTurns(List<Player> players)
        {
            List<TurnEventMessage> endOfTurnMessages = new List<TurnEventMessage>();

            foreach (Player comp in players)
            {
                if (comp.Type != PlayerType.Human)
                {
                    AI.ComputerTakeTurn(comp);
                }
            }

            //move ships called for all players before the rest of the end turn
            foreach (Player player in players)
            {
                GameTools.moveShips(player);
            }

            //could eventually prefer computer opponents
            foreach (Player player in players)
            {
                if (player == GameTools.GameModel.MainPlayer)
                    endOfTurnMessages.AddRange(GameTools.endTurn(player));
                else//don't add the messages
                    GameTools.endTurn(player);
            }

            //TODO: could eventually only allow repairs if the planet has a certain improvement (i.e. space platform and colony)
            //and/or only repair slowly and/or charge gold for repairing damange (i.e. 1 gold per 4 damage
            //repair fleets on planets
            foreach (Planet p in GameModel.Planets)
            {
                p.PlanetaryFleet.RepairFleet();
            }

            //resolve planetary conflicts
            foreach (Player player in players)
            {
                //resolve planetary conflicts deals with making sure the message pertains to the main player
                endOfTurnMessages.AddRange(GameTools.resolvePlanetaryConflicts(player));
            }

            endOfTurnMessages.Sort(new TurnEventMessageComparer());

            GameTools.checkPlayerDestroyedAndGameOver();

            return endOfTurnMessages;
        }

        public static Planet GetClosestUnownedPlanet(Player player, Planet playerOwnedPlanet, out int minDistance)
        {
            minDistance = 999;
            Planet closestUnownedPlanet = null;

            foreach (Planet p in GameTools.GameModel.Planets)
            {
                if (p.Id != playerOwnedPlanet.Id && p.Owner != player)
                {
                    int distance = GameTools.GameModel.GameGrid.GetHexDistance(playerOwnedPlanet.BoundingHex, p.BoundingHex);
                    if (distance < minDistance)
                    {
                        minDistance = distance;
                        closestUnownedPlanet = p;
                    }
                }
            }

            return closestUnownedPlanet;
        }

        private static List<TurnEventMessage> endTurn(Player player)
        {
            List<TurnEventMessage> endOfTurnMessages = new List<TurnEventMessage>();

            int totalPop = player.GetTotalPopulation();

            //this could all be done at the start of the turn also.
            endOfTurnMessages.AddRange(GameTools.eatAndStarve(player, totalPop));

            if (player.Type == PlayerType.Human)
            {
                addLastStarShipToQueueOnPlanets(player);
            }

            GameTools.generatePlayerResources(player);

            endOfTurnMessages.AddRange(GameTools.buildPlayerPlanetImprovements(player));

            endOfTurnMessages.AddRange(GameTools.growPlayerPlanetPopulation(player));

            return endOfTurnMessages;
        }

        private static void moveShips(Player player)
        {
            //for each fleet in transit, move the fleet towards it's destination
            foreach (Fleet f in player.FleetsInTransit)
            {
                f.MoveFleet();
            }

            //for each planet and each outgoing fleet on that planet, move the fleet to the player's fleets in transit and move it
            foreach (Planet p in player.OwnedPlanets.Values)
            {
                for (int i = p.OutgoingFleets.Count - 1; i >= 0 ; i-- )
                {
                    Fleet f = p.OutgoingFleets[i];
                    player.FleetsInTransit.Add(f);
                    f.MoveFleet();
                    p.OutgoingFleets.RemoveAt(i);
                }
            }

            //land fleets arriving on owned planets
            //merge multiple friendly fleets arriving on unowned planets (before conflicts are resolved)
            for (int i = player.FleetsInTransit.Count - 1; i >= 0; i--)
            {
                Fleet playerFleet = player.FleetsInTransit[i];
                if (playerFleet.TurnsToDestination == 0)
                {
                    Planet destinationPlanet = playerFleet.DestinationHex.PlanetContainedInHex;
                    if (destinationPlanet.Owner == player)
                    {
                        //merge/land fleet
                        destinationPlanet.PlanetaryFleet.LandFleet(playerFleet, playerFleet.DestinationHex);
                    }
                    else
                    {
                        player.AddFleetArrivingOnUnownedPlanet(destinationPlanet, playerFleet);
                    }
                    player.FleetsInTransit.RemoveAt(i);
                }
            }
            
        }

        //TODO: this is problematic right now if multiple players show up to battle at a 3rd players planet
        //  right now one player will attack, then the next one will, which prefers the 2nd player to attack
        private static List<TurnEventMessage> resolvePlanetaryConflicts(Player player)
        {
            List<TurnEventMessage> planetaryConflictMessages = new List<TurnEventMessage>();

            //if any of the player's fleets in transit have reached their destination
            //  if the destination is not an owned planet, we need to resolve the conflict
            //  once conflicts are resolved, merge fleets to the fleets of the owned planet
            List<Fleet> unownedPlanetFleets = player.GatherFleetsArrivingOnUnownedPlanets();
            foreach (Fleet playerFleet in unownedPlanetFleets)
            {
                Planet destinationPlanet = playerFleet.DestinationHex.PlanetContainedInHex;

                //battle!
                Fleet enemyFleet = destinationPlanet.PlanetaryFleet;

                int enemyFleetStrength = enemyFleet.DetermineFleetStrength();

                int playerFleetStrength = playerFleet.DetermineFleetStrength();

                //this is for our turn event message, the PlanetaryConflictData constructor deals with cloning the fleets
                PlanetaryConflictData planetaryConflictData = new PlanetaryConflictData(destinationPlanet.Owner, enemyFleet, player, playerFleet);

                //determine strength differences
                // GameTools.BATTLE_RANDOMNESS_FACTOR = 4 in this case
                //if one fleet's strength is 4 (log base 16 4 = .5) times as strong or more that fleet automatically wins
                //  damage done to winning fleet is (strength of loser / strength Multiplier) +- some randomness
                //if neither fleet is 4 times as strong as the other or more, we have to roll the dice (preferring the stronger fleet) for who wins

                //if the player's fleet is destroyed the enemy (defender) always wins because you can't land fleets and capture the system without fleets


                //July 21st 2010, changed from pure statistics to BattleSimulator, still have this AttackingFleetChances code to show a percentage (for now as an estimation)


                
                if (enemyFleetStrength > playerFleetStrength * GameTools.BATTLE_RANDOMNESS_FACTOR)
                {
                    planetaryConflictData.AttackingFleetChances = 1;
                }
                else if (playerFleetStrength > enemyFleetStrength * GameTools.BATTLE_RANDOMNESS_FACTOR)
                {
                    planetaryConflictData.AttackingFleetChances = enemyFleetStrength == 0 ? 100 : 99;
                }
                else
                {
                    //algorithm for estimated chance: BATTLE_RANDOMNESS_FACTOR here = 4
                    // % chance = 50 + LOG base 4(greater fleet strength / lesser fleet strength)
                    int randomnessUpperBounds = 0;
                    if (playerFleetStrength > enemyFleetStrength)
                    {
                        //prefer player
                        double extraPercentageChance = Math.Log(playerFleetStrength / (double)enemyFleetStrength, Math.Pow(GameTools.BATTLE_RANDOMNESS_FACTOR, 2)) * 100;//((playerFleetStrength - enemyFleetStrength) / (double)enemyFleetStrength) * 50;
                        randomnessUpperBounds = 50 + (int)Math.Round(extraPercentageChance);
                        planetaryConflictData.AttackingFleetChances = randomnessUpperBounds;
                    }
                    else
                    {
                        //prefer enemy
                        double extraPercentageChanceEnemy = Math.Log(enemyFleetStrength / (double)playerFleetStrength, Math.Pow(GameTools.BATTLE_RANDOMNESS_FACTOR, 2)) * 100;//((enemyFleetStrength - playerFleetStrength) / (double)playerFleetStrength) * 50;
                        randomnessUpperBounds = 50 + (int)Math.Round(extraPercentageChanceEnemy);
                        planetaryConflictData.AttackingFleetChances = 100 - randomnessUpperBounds;
                    }

                }

                //now actually simulate the battle
                bool? playerWins = BattleSimulator.SimulateFleetBattle(playerFleet, enemyFleet);
                //if at this point playerWins doesn't have a value it means that both fleets were destroyed, in that case the enemy should win because they are the defender of the planet
                if (!playerWins.HasValue)
                    playerWins = false;

                if (!playerWins.Value)
                {
                    //just kill the fleet
                    //make sure this planet is now explored
                    destinationPlanet.SetPlanetExplored(player);
                    playerFleet.SendFleetMergedOrDestroyed();

                    //notify user of fleet loss or defense
                    if (player == GameTools.GameModel.MainPlayer)//the attacking player is the main player and lost
                    {
                        //PlanetaryConflictData summarizes your attacking fleet, the enemy fleet and what was destroyed in the enemy fleet
                        string message = "You lost a fleet attacking planet: " + destinationPlanet.Name;
                        if(destinationPlanet.Owner != null)
                            message = "You lost a fleet attacking " + destinationPlanet.Owner.Name + " at planet: " + destinationPlanet.Name;
                        TurnEventMessage tem = new TurnEventMessage(TurnEventMessageType.AttackingFleetLost, destinationPlanet, message);
                        tem.Data = planetaryConflictData;
                        tem.Data.WinningFleet = enemyFleet.CloneFleet();
                        planetaryConflictMessages.Add(tem);
                    }
                    else if (destinationPlanet.Owner == GameTools.GameModel.MainPlayer)//the defending player is the main player and won
                    {
                        //PlanetaryConflictData summarizes the attacking fleet, your fleet and what was destroyed in your fleet
                        string message = "You successfully defended against " + player.Name + " attacking planet: " + destinationPlanet.Name;
                        TurnEventMessage tem = new TurnEventMessage(TurnEventMessageType.DefendedAgainstAttackingFleet, destinationPlanet, message);
                        tem.Data = planetaryConflictData;
                        tem.Data.WinningFleet = enemyFleet.CloneFleet();
                        planetaryConflictMessages.Add(tem);
                    }
                }
                else
                {
                    Player defendingPlayer = destinationPlanet.Owner;

                    //change planet ownership
                    destinationPlanet.SetPlanetOwner(player);
                    //create a new fleet, we'll land and merge in a sec
                    destinationPlanet.PlanetaryFleet = new Fleet();
                    //merge/land fleet
                    destinationPlanet.PlanetaryFleet.LandFleet(playerFleet, playerFleet.DestinationHex);

                    if (defendingPlayer != null)
                    {
                        //set last known fleet strength
                        destinationPlanet.SetPlayerLastKnownPlanetFleetStrength(defendingPlayer);
                    }

                    //notify user of planet capture or loss
                    if (player == GameTools.GameModel.MainPlayer)//the attacking player is the main player and won
                    {
                        //PlanetaryConflictData summarizes your attacking fleet, the enemy fleet and what was destroyed in your fleet
                        string message = "Your fleet captured planet: " + destinationPlanet.Name;
                        if(defendingPlayer != null)
                            message = "Your fleet captured planet: " + destinationPlanet.Name + ", owned by: " + defendingPlayer.Name;
                        TurnEventMessage tem = new TurnEventMessage(TurnEventMessageType.PlanetCaptured, destinationPlanet, message);
                        tem.Data = planetaryConflictData;
                        tem.Data.WinningFleet = playerFleet.CloneFleet();
                        planetaryConflictMessages.Add(tem);
                    }
                    else if (defendingPlayer == GameTools.GameModel.MainPlayer)//the defending player is the main player and lost
                    {
                        //planetaryConflictData summarizes your defending fleet, the enemy fleet and what was destroyed in the enemy fleet
                        string message = player.Name + " captured your planet: " + destinationPlanet.Name;
                        TurnEventMessage tem = new TurnEventMessage(TurnEventMessageType.PlanetLost, destinationPlanet, message);
                        tem.Data = planetaryConflictData;
                        tem.Data.WinningFleet = playerFleet.CloneFleet();
                        planetaryConflictMessages.Add(tem);
                    }
                }

            }

            return planetaryConflictMessages;
        }

        private static List<TurnEventMessage> eatAndStarve(Player player, int totalPop)
        {
            List<TurnEventMessage> eotMessages = new List<TurnEventMessage>();
            //for each planet player controls

            //if one planet has a shortage and another a surplus, gold will be spent (if possible) for shipping

            //determine food surplus and shortages
            //shortages will kill off a percentage of the population due to starvation depending on the amount of shortage

            player.LastTurnFoodNeededToBeShipped = 0;

            Dictionary<Planet, int> foodDeficitByPlanet = new Dictionary<Planet, int>();//for calculating starvation later
            List<Planet> foodSurplusPlanets = new List<Planet>();//for costing shipments and starvation later

            //calculate surpluses and deficits
            foreach (Planet p in player.OwnedPlanets.Values)
            {
                p.PlanetHappiness = PlanetHappinessType.Normal;//reset our happiness

                p.Resources.FoodAmount = p.Resources.FoodAmount - p.Population.Count;//eat

                if (p.Resources.FoodAmount < 0)
                {
                    int deficit = Math.Abs(p.Resources.FoodAmount);
                    foodDeficitByPlanet.Add(p, deficit);//signify deficit for starvation
                    p.Resources.FoodAmount = 0;

                    player.LastTurnFoodNeededToBeShipped += deficit;//increment our food shipments needed so next turn we can ensure we have surplus gold
                }
                else if (p.Resources.FoodAmount > 0)//signify surplus for this planet for shipments
                {
                    foodSurplusPlanets.Add(p);
                }
            }

            int totalFoodShipped = 0;

            string protestingPlanetNames = "";
            int protestingPlanetCount = 0;
            Planet lastProtestingPlanet = null;

            //starve if we don't have surplus at other planets or can't afford to pay for shipments
            foreach (KeyValuePair<Planet, int> deficit in foodDeficitByPlanet)
            {
                int foodShortageTotal = deficit.Value;
                bool shippedAllResources = false;//if we shipped enough food to prevent starvation
                //first see if we can pay for any shipping and there are planets with surplus
                if (player.Resources.GoldAmount > 0 && foodSurplusPlanets.Count > 0)//it will cost one gold per resource shipped
                {
                    //look for a planet to send food from
                    for (int s = 0; s < foodSurplusPlanets.Count; s++)
                    {
                        Planet pSurplus = foodSurplusPlanets[s];
                        int amountSpent = 0;
                        
                        if (foodShortageTotal > pSurplus.Resources.FoodAmount)//we can't get all our shortage from this one planet
                        {
                            amountSpent = player.Resources.SpendGoldAsPossible(pSurplus.Resources.FoodAmount);
                        }
                        else//we've can satisfy this deficit if we can pay for it, pay for as much shipping as we can
                        {
                            amountSpent = player.Resources.SpendGoldAsPossible(foodShortageTotal);
                        }
                        totalFoodShipped += amountSpent;

                        foodShortageTotal = foodShortageTotal - amountSpent;
                        pSurplus.Resources.FoodAmount = pSurplus.Resources.FoodAmount - amountSpent;

                        if (pSurplus.Resources.FoodAmount == 0)//remove it for faster processing
                        {
                            foodSurplusPlanets.RemoveAt(s);
                            s--;
                        }

                        if (foodShortageTotal == 0)//we shipped enough food
                        {
                            shippedAllResources = true;
                            break;
                        }

                    }
                }

                if (!shippedAllResources)
                {
                    double foodShortageRatio = foodShortageTotal / (double)totalPop;
                    //starvation
                    //there is a food shortage ratio chance of loosing one population,
                    //if you have 4 pop and 2 food you have a 1 in 2 chance of loosing one
                    //otherwise people just slowly starve
                    bool looseOne = (GameTools.Randomizer.Next(0, 100) < (int)Math.Round(foodShortageRatio * 100));
                    if (looseOne)
                    {
                        string riotReason = ".";//for shortages
                        if (player.Resources.GoldAmount <= 0 && foodSurplusPlanets.Count != 0)
                            riotReason = ", insufficient Gold to ship Food.";
                        //notify user of starvation
                        deficit.Key.PlanetHappiness = PlanetHappinessType.Riots;
                        eotMessages.Add(new TurnEventMessage(TurnEventMessageType.FoodShortageRiots, deficit.Key, "Riots over food shortages killed one population on planet: " + deficit.Key.Name + riotReason));
                        if (deficit.Key.Population.Count > 0)
                        {
                            deficit.Key.Population.RemoveAt(deficit.Key.Population.Count - 1);
                            //don't have to update planet stats based on population here because we'll do it later
                        }
                    }
                    else//reduce the population a bit
                    {
                        if (deficit.Key.Population.Count > 0)
                        {
                            deficit.Key.PlanetHappiness = PlanetHappinessType.Unrest;

                            Citizen c = deficit.Key.Population[deficit.Key.Population.Count - 1];
                            c.PopulationChange -= foodShortageRatio;
                            if (c.PopulationChange <= -1.0)
                            {
                                //notify user of starvation
                                eotMessages.Add(new TurnEventMessage(TurnEventMessageType.PopulationStarvation, deficit.Key, "You lost one population due to food shortages on planet: " + deficit.Key.Name));
                                deficit.Key.Population.RemoveAt(deficit.Key.Population.Count - 1);
                                //don't have to update planet stats based on population here because we'll do it later
                            }
                            else
                            {
                                protestingPlanetCount++;

                                if (protestingPlanetNames != "")
                                    protestingPlanetNames += ", ";
                                protestingPlanetNames += deficit.Key.Name;

                                lastProtestingPlanet = deficit.Key;
                            }
                        }
                    }

                    //have to check to see if we removed the last pop and loose this planet from owned planets if so
                    if (deficit.Key.Population.Count == 0)
                    {
                        //notify user of planet loss
                        eotMessages.Add(new TurnEventMessage(TurnEventMessageType.PlanetLostDueToStarvation, deficit.Key, "You have lost control of " + deficit.Key.Name + " due to starvation"));

                        deficit.Key.SetPlanetOwner(null);

                        //set last known fleet strength
                        deficit.Key.SetPlayerLastKnownPlanetFleetStrength(player);
                    }
                }
            }

            if (protestingPlanetCount > 0)
            {
                string protestingPlanetReason = ".";
                if (player.Resources.GoldAmount <= 0 && foodSurplusPlanets.Count != 0)
                    protestingPlanetReason = ", insufficient Gold to ship Food.";
                string planetPluralized = "planet: ";
                if (protestingPlanetCount > 1)
                    planetPluralized = "planets: ";
                //notify user of population unrest
                eotMessages.Add(new TurnEventMessage(TurnEventMessageType.InsufficientFood, lastProtestingPlanet, "Population unrest over lack of Food on " + planetPluralized + protestingPlanetNames + protestingPlanetReason));
            }
                                

            if(totalFoodShipped != 0)
                eotMessages.Add(new TurnEventMessage(TurnEventMessageType.FoodShipped, null, "You spent " + totalFoodShipped + " Gold shipping Food.")); 

            //TODO: food shortages should further reduce other production, and pop reproduction amt?

            return eotMessages;
        }

        private static void generatePlayerResources(Player player)
        {
            //determine tax revenue (gold)
            //for now we generate 1/2 gold for each worker, farmer, or miner
            //TODO: later we may want to allow the user to control taxes vs. research 
            int totalWorkers = 0, totalfarmers=0, totalMiners=0;
            int farmers, miners, workers;
            foreach (Planet p in player.OwnedPlanets.Values)
            {
                p.CountPopulationWorkerTypes(out farmers, out miners, out workers);
                totalWorkers += workers;
                totalfarmers += farmers;
                totalMiners += miners;
            }
            player.Resources.GoldRemainder += (totalWorkers + totalMiners + totalfarmers) / 2.0;
            player.Resources.AccumulateResourceRemainders();

            //generate planet resources
            foreach (Planet p in player.OwnedPlanets.Values)
            {
                p.GenerateResources();
            }


        }

        private static void addLastStarShipToQueueOnPlanets(Player player)
        {
            foreach (Planet p in player.OwnedPlanets.Values)
            {
                if (p.BuildLastStarShip && p.BuildQueue.Count == 0 && p.StarShipTypeLastBuilt.HasValue)
                {
                    //check resources
                    StarShipInProduction s = new StarShipInProduction(p.StarShipTypeLastBuilt.Value);

                    if (player.Resources.GoldAmount - s.GoldCost > player.LastTurnFoodNeededToBeShipped &&
                        player.Resources.OreAmount - s.OreCost >= 0 &&
                        player.Resources.IridiumAmount - s.IridiumCost >= 0)
                    {
                        p.EnqueueProductionItemAndSpendResources(s, player.Resources);
                    }
                }
            }
        }

        private static List<TurnEventMessage> buildPlayerPlanetImprovements(Player player)
        {
            List<TurnEventMessage> endOfTurnMessages = new List<TurnEventMessage>();
            //build planet improvements
            foreach (Planet p in player.OwnedPlanets.Values)
            {
                bool buildQueueEmpty = false;
                endOfTurnMessages.AddRange(p.BuildImprovements(out buildQueueEmpty));
                if (buildQueueEmpty)//if the build queue was empty we'll increase gold based on planet production
                {
                    if (p.ResourcesPerTurn.ProductionAmountPerTurn > 0)
                    {
                        player.Resources.GoldRemainder += p.ResourcesPerTurn.ProductionAmountPerTurn / 4.0;
                        player.Resources.AccumulateResourceRemainders();
                    }
                }
            }
            return endOfTurnMessages;
        }

        private static List<TurnEventMessage> growPlayerPlanetPopulation(Player player)
        {
            List<TurnEventMessage> endOfTurnMessages = new List<TurnEventMessage>();
            //population growth rate is based on available space at the planet and the amount currently there
            //as we fill up the planet, growth rate slows
            foreach (Planet p in player.OwnedPlanets.Values)
            {
                int popCount = p.Population.Count;
                //check if we can grow
                if (popCount > 0 && p.PlanetHappiness != PlanetHappinessType.Riots && (popCount < p.MaxPopulation || p.Population[popCount - 1].PopulationChange < 1.0))
                {
                    double growthRatio = popCount / 4.0 * ((p.MaxPopulation - popCount) / 8.0);
                    if (p.PlanetHappiness == PlanetHappinessType.Unrest)//unrest slows pop growth
                        growthRatio = growthRatio / 2.0;
                    Citizen lastCitizen = p.Population[popCount - 1];
                    lastCitizen.PopulationChange += growthRatio;
                    if (lastCitizen.PopulationChange >= 1.0)
                    {
                        //notify user of growth
                        endOfTurnMessages.Add(new TurnEventMessage(TurnEventMessageType.PopulationGrowth, p, "Population growth on planet: " + p.Name));
                        //grow
                        lastCitizen.PopulationChange = 0;
                        p.Population.Add(new Citizen(p.Type));
                        p.ResourcesPerTurn.UpdateResourcesPerTurnBasedOnPlanetStats();
                    }
                }
            }

            return endOfTurnMessages;
        }

        private static void checkPlayerDestroyedAndGameOver()
        {
            bool mainPlayerDestroyed = false;

            List<Player> destroyedPlayers = new List<Player>();
            foreach (Player player in GameTools.GameModel.Players)
            {
                //a player is destroyed if they have no owned planets and no fleets in transit
                if (player.OwnedPlanets.Count == 0 && player.FleetsInTransit.Count == 0)
                {
                    destroyedPlayers.Add(player);
                    if (player == GameModel.MainPlayer)
                        mainPlayerDestroyed = true;
                }
            }

            foreach (Player player in destroyedPlayers)
            {
                GameTools.GameModel.Players.Remove(player);
            }

            if (GameTools.GameModel.Players.Count > 1 && !mainPlayerDestroyed)
            {
                if (GameTools.OnPlayerDestroyed != null)
                {
                    foreach (Player player in destroyedPlayers)
                        GameTools.OnPlayerDestroyed(player);
                }
            }
            else
            {
                if (GameTools.OnPlayerDestroyedGameOver != null)
                {
                    GameTools.OnPlayerDestroyedGameOver(GameTools.GameModel.Players[0]);
                }
            }
        }

        public static int CalculateEndGamePoints(Player player, bool playerWon)
        {
            int points = 0;

            int turnsTaken = GameModel.Turn.Number;
            if (turnsTaken > 1000)//some max, nobody should play this long?
                turnsTaken = 1000;
            
            int totalSystems = GameModel.SystemsToGenerate;
            int planetsPerSystem = (int)GameModel.PlanetsPerSystem;
            int difficultyRating = totalSystems * planetsPerSystem - 8;
            foreach (Player p in GameModel.Players)
            {
                if (p.Type == PlayerType.Computer_Easy)
                    difficultyRating += 1;
                else if (p.Type == PlayerType.Computer_Normal)
                    difficultyRating += 2;
                else if (p.Type == PlayerType.Computer_Hard)
                    difficultyRating += 3;
                else if (p.Type == PlayerType.Computer_Expert)
                    difficultyRating += 4;
            }
            //max difficulty right now is 4 * 8 - 8 + 12 = 36
            //min is 1
            double speedFactor = (difficultyRating * 1.0)/(turnsTaken * 1.0);

            int ownedPlanets = player.OwnedPlanets.Count;
            if (ownedPlanets == 0)
                ownedPlanets = 1;//so that we have points for loosers too
            int totalPopulation = player.GetTotalPopulation();
            if (totalPopulation == 0)
                totalPopulation = 1;//so that we have points for loosers too

            points = (int)Math.Round((speedFactor * difficultyRating * ownedPlanets) + (totalPopulation * totalSystems));

            return points;
        }
    }
}
