var Astriarch = {Version: '1.2.1', GameModel:null};

Astriarch.NextRandom = function(lowInclusive, highExclusive) {

	if(highExclusive === null || typeof highExclusive == "undefined")
	{
		highExclusive = lowInclusive;
		lowInclusive = 0;
	}
	
	if(lowInclusive < 0)
		highExclusive += Math.abs(lowInclusive);
	else
		highExclusive -= lowInclusive;

	return Math.floor(Math.random()*highExclusive) + lowInclusive;
};

//could add as prototype to object but that may cause problems:
//http://stackoverflow.com/questions/5223/length-of-javascript-associative-array
Astriarch.CountObjectKeys = function(obj) {
	var count = 0;
	for (var k in obj)
      count++;
	return count;
};

Number.prototype.compareTo = function(num) {
	 if (typeof num != "number") return false; // if number is not of type number return false

	 if (num < this) return 1;
	 else if (num > this) return -1;
	 else return 0;
};

Astriarch.GameTools = {
	
	BATTLE_RANDOMNESS_FACTOR: 4.0,//the amount randomness (chance) when determining fleet conflict outcomes, it is the strength multiplyer where the winner is guaranteed to win

	PlanetOwnerToFriendlyName: function(/*Planet*/ p, /*Player*/ planetOwner){//returns string
		var owner = (p.Type == Astriarch.Planet.PlanetType.AsteroidBelt) ? "None" : "Natives";
		if (planetOwner != null)
			owner = planetOwner.Name;

		return owner;
	},

	PlanetTypeToFriendlyName: function(/*PlanetType*/ t){//returns string
		var typeName = "Asteroid Belt";
		if (t == Astriarch.Planet.PlanetType.DeadPlanet)
			typeName = "Dead";
		else if (t == Astriarch.Planet.PlanetType.PlanetClass1)
			typeName = "Arid";//formerly "Mineral Rich"
		else if (t == Astriarch.Planet.PlanetType.PlanetClass2)
			typeName = "Terrestrial";

		return typeName;
	},

	PlanetImprovementTypeToFriendlyName: function(/*PlanetImprovementType*/ t){//returns string
		var name = "";
		switch(t)
		{
			case Astriarch.Planet.PlanetImprovementType.Factory:
				name = "Factory";
				break;
			case Astriarch.Planet.PlanetImprovementType.Colony:
				name = "Colony";
				break;
			case Astriarch.Planet.PlanetImprovementType.Farm:
				name = "Farm";
				break;
			case Astriarch.Planet.PlanetImprovementType.Mine:
				name = "Mine";
				break;
			case Astriarch.Planet.PlanetImprovementType.SpacePlatform:
				name = "Space Platform";
				break;
		}
		return name;
	},

	PlanetImprovementTypeToHelpText: function(/*PlanetImprovementType*/ t){//returns string
		var helpText = "";
		switch (t)
		{
			case Astriarch.Planet.PlanetImprovementType.Farm:
				helpText = "Farms increase amount of Food produced by each farmer.";
				break;
			case Astriarch.Planet.PlanetImprovementType.Mine:
				helpText = "Mines increase the amount of Ore and Iridium produced by each miner.";
				break;
			case Astriarch.Planet.PlanetImprovementType.Factory:
				helpText = "Factories increase the production generated by each worker.\r\n" +
                           "Allows construction of Space Platforms and Destroyers.";
				break;
			case Astriarch.Planet.PlanetImprovementType.Colony:
				helpText = "Colonies increase the planet's maximum population by one.";
				break;
			case Astriarch.Planet.PlanetImprovementType.SpacePlatform:
				helpText = "Space Platforms provide planetary defense.\r\n" +
                           "Allows construction of Cruisers and Battleships.\r\n" +
                           "Advantage against: Destroyers, Disadvantage Against: Cruisers";
				break;
		}

		return helpText;
	},

	StarShipTypeToFriendlyName: function(/*StarShipType*/ t)
	{
		var name = "";
		switch(t)
		{
			case Astriarch.Fleet.StarShipType.SystemDefense:
				name = "Defender";
				break;
			case Astriarch.Fleet.StarShipType.Scout:
				name = "Scout";
				break;
			case Astriarch.Fleet.StarShipType.Destroyer:
				name = "Destroyer";
				break;
			case Astriarch.Fleet.StarShipType.Cruiser:
				name = "Cruiser";
				break;
			case Astriarch.Fleet.StarShipType.Battleship:
				name = "Battleship";
				break;
		}
		return name;
	},

	StarShipTypeToHelpText: function(/*StarShipType*/ t){
		//here are the advantages (-> means has an advantage over):
		//defenders -> destroyers -> battleships -> cruisers -> spaceplatforms -> scouts (-> defenders)
		var helpText = "";
		switch (t)
		{
			case Astriarch.Fleet.StarShipType.SystemDefense:
				helpText = "Defenders protect a planet from attacking fleets but cannot move between planets.\r\n" +
						   "Advantage against: Destroyers, Disadvantage Against: Scouts";
				break;
			case Astriarch.Fleet.StarShipType.Scout:
				helpText = "Scouts are the weakest ship equipped with warp drive.\r\n" +
						   "Advantage against: Defenders, Disadvantage Against: Space Platforms";
				break;
			case Astriarch.Fleet.StarShipType.Destroyer:
				helpText = "Destroyers require a Factory in order to build and are twice the strength of a Scout.\r\n" +
						   "Advantage against: Battleships, Disadvantage Against: Defenders";
				break;
			case Astriarch.Fleet.StarShipType.Cruiser:
				helpText = "Cruisers require a Space Platform in order to build and are twice the strength of a Destroyer.\r\n" +
						   "Advantage against: Space Platforms, Disadvantage Against: Battleships";
				break;
			case Astriarch.Fleet.StarShipType.Battleship:
				helpText = "Battleships require a Space Platform in order to build and are twice the strength of a Cruiser.\r\n" +
						   "Advantage against: Cruisers, Disadvantage Against: Destroyers";
				break;
		}

		return helpText;
	},

	/// <summary>
	/// Finishes (takes) the turns for all AI opponents and builds resources for everyone
	/// </summary>
	/// <param name="players">all players in the model</param>
	EndTurns: function(/*List<Player>*/ players)	{//returns List<TurnEventMessage>
		var endOfTurnMessages = []; //List<TurnEventMessage>

		for (var i in players)
		{
			var comp = players[i];
			if (comp.Type != Astriarch.Player.PlayerType.Human)
			{
				Astriarch.AI.ComputerTakeTurn(comp);
			}
		}

		//move ships called for all players before the rest of the end turn
		for (var i in players)
		{
			Astriarch.GameTools.moveShips(players[i]);
		}

		//could eventually prefer computer opponents
		for (var i in players)
		{
			var player = players[i];
			if (player == Astriarch.GameModel.MainPlayer)
				endOfTurnMessages = endOfTurnMessages.concat(Astriarch.GameTools.endTurn(player));
			else//don't add the messages
				Astriarch.GameTools.endTurn(player);
		}

		//TODO: could eventually only allow repairs if the planet has a certain improvement (i.e. space platform and colony)
		//and/or only repair slowly and/or charge gold for repairing damange (i.e. 1 gold per 4 damage
		//repair fleets on planets
		for (var i in Astriarch.GameModel.Planets)
		{
			Astriarch.GameModel.Planets[i].PlanetaryFleet.RepairFleet();
		}

		//resolve planetary conflicts
		for (var i in players)
		{
			//resolve planetary conflicts deals with making sure the message pertains to the main player
			endOfTurnMessages = endOfTurnMessages.concat(Astriarch.GameTools.resolvePlanetaryConflicts(players[i]));
		}

		endOfTurnMessages.sort(Astriarch.TurnEventMessage.TurnEventMessageComparerSortFunction);

		Astriarch.GameTools.checkPlayerDestroyedAndGameOver();

		return endOfTurnMessages;
	},

	//minDistance object is for out parameters: {minDistance: 999}
	GetClosestUnownedPlanet: function(/*Player*/ player, /*Planet*/ playerOwnedPlanet, minDistanceObject){//returns Planet
		minDistanceObject['minDistance'] = 999;
		var closestUnownedPlanet = null;//Planet

		for (var i in Astriarch.GameModel.Planets)
		{
			var p = Astriarch.GameModel.Planets[i];//Planet
			if (p.Id != playerOwnedPlanet.Id && p.Owner != player)
			{
				var distance = Astriarch.GameModel.GameGrid.GetHexDistance(playerOwnedPlanet.BoundingHex, p.BoundingHex);
				if (distance < minDistanceObject['minDistance'])
				{
					minDistanceObject['minDistance'] = distance;
					closestUnownedPlanet = p;
				}
			}
		}

		return closestUnownedPlanet;
	},

	endTurn: function(/*Player*/ player){//returns List<TurnEventMessage>
		var endOfTurnMessages = []; //List<TurnEventMessage>

		var totalPop = player.GetTotalPopulation();

		//this could all be done at the start of the turn also.
		endOfTurnMessages = endOfTurnMessages.concat(Astriarch.GameTools.eatAndStarve(player, totalPop));

		if(player.Type == Astriarch.Player.PlayerType.Human) {
			Astriarch.GameTools.addLastStarShipToQueueOnPlanets(player);
		}
		
		Astriarch.GameTools.generatePlayerResources(player);

		endOfTurnMessages = endOfTurnMessages.concat(Astriarch.GameTools.buildPlayerPlanetImprovements(player));

		endOfTurnMessages = endOfTurnMessages.concat(Astriarch.GameTools.growPlayerPlanetPopulation(player));

		return endOfTurnMessages;
	},

	moveShips: function(/*Player*/ player){
		//for each fleet in transit, move the fleet towards it's destination
		for (var i in player.FleetsInTransit)
		{
			player.FleetsInTransit[i].MoveFleet();
		}

		//for each planet and each outgoing fleet on that planet, move the fleet to the player's fleets in transit and move it
		for (var pi in player.OwnedPlanets)
		{
			var p = player.OwnedPlanets[pi];
			for (var i = p.OutgoingFleets.length - 1; i >= 0 ; i-- )
			{
				var f = p.OutgoingFleets[i];//Fleet
				player.FleetsInTransit.push(f);
				f.MoveFleet();
				p.OutgoingFleets.splice(i, 1);
			}
		}

		//land fleets arriving on owned planets
		//merge multiple friendly fleets arriving on unowned planets (before conflicts are resolved)
		for (var i = player.FleetsInTransit.length - 1; i >= 0; i--)
		{
			var playerFleet = player.FleetsInTransit[i];//Fleet
			if (playerFleet.DrawnFleet.TurnsToDestination == 0)
			{
				var destinationPlanet = playerFleet.DestinationHex.PlanetContainedInHex;//Planet
				if (destinationPlanet.Owner == player)
				{
					//merge/land fleet
					destinationPlanet.PlanetaryFleet.LandFleet(playerFleet, playerFleet.DestinationHex);
				}
				else
				{
					player.AddFleetArrivingOnUnownedPlanet(destinationPlanet, playerFleet);
				}
				player.FleetsInTransit.splice(i, 1);
			}
		}
		
	},

	//TODO: this is problematic right now if multiple players show up to battle at a 3rd players planet
	//  right now one player will attack, then the next one will, which prefers the 2nd player to attack
	resolvePlanetaryConflicts: function(/*Player*/ player) {//returns List<TurnEventMessage>
		var planetaryConflictMessages = []; //List<TurnEventMessage>

		//if any of the player's fleets in transit have reached their destination
		//  if the destination is not an owned planet, we need to resolve the conflict
		//  once conflicts are resolved, merge fleets to the fleets of the owned planet
		var unownedPlanetFleets = player.GatherFleetsArrivingOnUnownedPlanets();//List<Fleet>
		for (var i in unownedPlanetFleets)
		{
			var playerFleet = unownedPlanetFleets[i];//Fleet
			var destinationPlanet = playerFleet.DestinationHex.PlanetContainedInHex;//Planet

			//battle!
			var enemyFleet = destinationPlanet.PlanetaryFleet;//Fleet

			var enemyFleetStrength = enemyFleet.DetermineFleetStrength();

			var playerFleetStrength = playerFleet.DetermineFleetStrength();

			//this is for our turn event message, the PlanetaryConflictData constructor deals with cloning the fleets
			var planetaryConflictData = new Astriarch.TurnEventMessage.PlanetaryConflictData(destinationPlanet.Owner, enemyFleet, player, playerFleet);

			//determine strength differences
			// GameTools.BATTLE_RANDOMNESS_FACTOR = 4 in this case
			//if one fleet's strength is 4 (log base 16 4 = .5) times as strong or more that fleet automatically wins
			//  damage done to winning fleet is (strength of loser / strength Multiplier) +- some randomness
			//if neither fleet is 4 times as strong as the other or more, we have to roll the dice (preferring the stronger fleet) for who wins

			//if the player's fleet is destroyed the enemy (defender) always wins because you can't land fleets and capture the system without fleets


			//July 21st 2010, changed from pure statistics to BattleSimulator, still have this AttackingFleetChances code to show a percentage (for now as an estimation)


			
			if (enemyFleetStrength > playerFleetStrength * Astriarch.GameTools.BATTLE_RANDOMNESS_FACTOR)
			{
				planetaryConflictData.AttackingFleetChances = 1;
			}
			else if (playerFleetStrength > enemyFleetStrength * Astriarch.GameTools.BATTLE_RANDOMNESS_FACTOR)
			{
				planetaryConflictData.AttackingFleetChances = enemyFleetStrength == 0 ? 100 : 99;
			}
			else
			{
				//algorithm for estimated chance: BATTLE_RANDOMNESS_FACTOR here = 4
				// % chance = 50 + LOG base 4(greater fleet strength / lesser fleet strength)
				var randomnessUpperBounds = 0;
				if (playerFleetStrength > enemyFleetStrength)
				{
					//prefer player
					var extraPercentageChance = Math.log(playerFleetStrength / (enemyFleetStrength * 1.0)) / Math.log(Math.pow(Astriarch.GameTools.BATTLE_RANDOMNESS_FACTOR, 2)) * 100;//((playerFleetStrength - enemyFleetStrength) / (double)enemyFleetStrength) * 50;
					randomnessUpperBounds = 50 + Math.round(extraPercentageChance);
					planetaryConflictData.AttackingFleetChances = randomnessUpperBounds;
				}
				else
				{
					//prefer enemy
					var extraPercentageChanceEnemy = Math.log(enemyFleetStrength / (playerFleetStrength * 1.0)) / Math.log(Math.pow(Astriarch.GameTools.BATTLE_RANDOMNESS_FACTOR, 2)) * 100;//((enemyFleetStrength - playerFleetStrength) / (double)playerFleetStrength) * 50;
					randomnessUpperBounds = 50 + Math.round(extraPercentageChanceEnemy);
					planetaryConflictData.AttackingFleetChances = 100 - randomnessUpperBounds;
				}

			}

			//now actually simulate the battle
			var playerWins = Astriarch.BattleSimulator.SimulateFleetBattle(playerFleet, enemyFleet);//bool?
			//if at this point playerWins doesn't have a value it means that both fleets were destroyed, in that case the enemy should win because they are the defender of the planet
			if (playerWins === null || typeof playerWins == "undefined")
				playerWins = false;

			if (!playerWins)
			{
				//just kill the fleet
				//make sure this planet is now explored
				destinationPlanet.SetPlanetExplored(player);
				playerFleet.SendFleetMergedOrDestroyed();

				//notify user of fleet loss or defense
				if (player == Astriarch.GameModel.MainPlayer)//the attacking player is the main player and lost
				{
					//PlanetaryConflictData summarizes your attacking fleet, the enemy fleet and what was destroyed in the enemy fleet
					var message = "You lost a fleet attacking planet: " + destinationPlanet.Name;
					if(destinationPlanet.Owner != null)
						message = "You lost a fleet attacking " + destinationPlanet.Owner.Name + " at planet: " + destinationPlanet.Name;
					var tem = new Astriarch.TurnEventMessage(Astriarch.TurnEventMessage.TurnEventMessageType.AttackingFleetLost, destinationPlanet, message);
					tem.Data = planetaryConflictData;
					tem.Data.WinningFleet = enemyFleet.CloneFleet();
					planetaryConflictMessages.push(tem);
				}
				else if (destinationPlanet.Owner == Astriarch.GameModel.MainPlayer)//the defending player is the main player and won
				{
					//PlanetaryConflictData summarizes the attacking fleet, your fleet and what was destroyed in your fleet
					var message = "You successfully defended against " + player.Name + " attacking planet: " + destinationPlanet.Name;
					var tem = new Astriarch.TurnEventMessage(Astriarch.TurnEventMessage.TurnEventMessageType.DefendedAgainstAttackingFleet, destinationPlanet, message);
					tem.Data = planetaryConflictData;
					tem.Data.WinningFleet = enemyFleet.CloneFleet();
					planetaryConflictMessages.push(tem);
				}
			}
			else
			{
				var defendingPlayer = destinationPlanet.Owner;//Player

				//change planet ownership
				var goldLootMax = destinationPlanet.SetPlanetOwner(player);
				
				if(defendingPlayer)
				{
					//give the conquering player a chance to loot gold from the planet
					//based on how good the planet it (class) and the amount refunded when everything was taken out of the build queue
					goldLootMax += Math.floor(Math.pow((destinationPlanet.Type + 1), 2));
					if(player.Resources.GoldAmount < goldLootMax)
						goldLootMax = defendingPlayer.Resources.GoldAmount;
					
					planetaryConflictData.GoldAmountLooted = Astriarch.NextRandom(0, Math.floor(goldLootMax + 1));
					defendingPlayer.Resources.GoldAmount -= planetaryConflictData.GoldAmountLooted;
					player.Resources.GoldAmount += planetaryConflictData.GoldAmountLooted;
				}
				
				//create a new fleet, we'll land and merge in a sec
				destinationPlanet.PlanetaryFleet = new Astriarch.Fleet();
				//merge/land fleet
				destinationPlanet.PlanetaryFleet.LandFleet(playerFleet, playerFleet.DestinationHex);

				if (defendingPlayer != null)
				{
					//set last known fleet strength
					destinationPlanet.SetPlayerLastKnownPlanetFleetStrength(defendingPlayer);
				}

				//notify user of planet capture or loss
				if (player == Astriarch.GameModel.MainPlayer)//the attacking player is the main player and won
				{
					//PlanetaryConflictData summarizes your attacking fleet, the enemy fleet and what was destroyed in your fleet
					var message = "Your fleet captured planet: " + destinationPlanet.Name;
					if(defendingPlayer != null)
						message = "Your fleet captured planet: " + destinationPlanet.Name + ", owned by: " + defendingPlayer.Name;
					var tem = new Astriarch.TurnEventMessage(Astriarch.TurnEventMessage.TurnEventMessageType.PlanetCaptured, destinationPlanet, message);
					tem.Data = planetaryConflictData;
					tem.Data.WinningFleet = playerFleet.CloneFleet();
					planetaryConflictMessages.push(tem);
				}
				else if (defendingPlayer == Astriarch.GameModel.MainPlayer)//the defending player is the main player and lost
				{
					//planetaryConflictData summarizes your defending fleet, the enemy fleet and what was destroyed in the enemy fleet
					var message = player.Name + " captured your planet: " + destinationPlanet.Name;
					var tem = new Astriarch.TurnEventMessage(Astriarch.TurnEventMessage.TurnEventMessageType.PlanetLost, destinationPlanet, message);
					tem.Data = planetaryConflictData;
					tem.Data.WinningFleet = playerFleet.CloneFleet();
					planetaryConflictMessages.push(tem);
				}
			}

		}

		return planetaryConflictMessages;
	},

	eatAndStarve: function(/*Player*/ player, /*int*/ totalPop) {
		var eotMessages = []; //List<TurnEventMessage>
		//for each planet player controls

		//if one planet has a shortage and another a surplus, gold will be spent (if possible) for shipping

		//determine food surplus and shortages
		//shortages will kill off a percentage of the population due to starvation depending on the amount of shortage

		player.LastTurnFoodNeededToBeShipped = 0;

		var foodDeficitByPlanet = {}; //Dictionary<PlanetId, int>();//for calculating starvation later
		var foodSurplusPlanets = []; //List<Planet>();//for costing shipments and starvation later

		//calculate surpluses and deficits
		for (var i in player.OwnedPlanets)
		{
			var p = player.OwnedPlanets[i];//Planet
			p.PlanetHappiness = Astriarch.Planet.PlanetHappinessType.Normal;//reset our happiness

			p.Resources.FoodAmount = p.Resources.FoodAmount - p.Population.length;//eat

			if (p.Resources.FoodAmount < 0)
			{
				var deficit = Math.abs(p.Resources.FoodAmount);
				foodDeficitByPlanet[p.Id] = deficit;//signify deficit for starvation
				p.Resources.FoodAmount = 0;

				player.LastTurnFoodNeededToBeShipped += deficit;//increment our food shipments needed so next turn we can ensure we have surplus gold
			}
			else if (p.Resources.FoodAmount > 0)//signify surplus for this planet for shipments
			{
				foodSurplusPlanets.push(p);
			}
		}

		var totalFoodShipped = 0;

		var protestingPlanetNames = "";
		var protestingPlanetCount = 0;
		var lastProtestingPlanet = null;//Planet

		//starve if we don't have surplus at other planets or can't afford to pay for shipments
		for (var planetId in foodDeficitByPlanet)
		{
			var planet = player.OwnedPlanets[planetId];
			var deficit = foodDeficitByPlanet[planetId];//KeyValuePair<PlanetId, int>
			var foodShortageTotal = deficit;
			var shippedAllResources = false;//if we shipped enough food to prevent starvation
			//first see if we can pay for any shipping and there are planets with surplus
			if (player.Resources.GoldAmount > 0 && foodSurplusPlanets.length > 0)//it will cost one gold per resource shipped
			{
				//look for a planet to send food from
				for (var s = 0; s < foodSurplusPlanets.length; s++)
				{
					var pSurplus = foodSurplusPlanets[s];//Planet
					var amountSpent = 0;
					
					if (foodShortageTotal > pSurplus.Resources.FoodAmount)//we can't get all our shortage from this one planet
					{
						amountSpent = player.Resources.SpendGoldAsPossible(pSurplus.Resources.FoodAmount);
					}
					else//we've can satisfy this deficit if we can pay for it, pay for as much shipping as we can
					{
						amountSpent = player.Resources.SpendGoldAsPossible(foodShortageTotal);
					}
					totalFoodShipped += amountSpent;

					foodShortageTotal = foodShortageTotal - amountSpent;
					pSurplus.Resources.FoodAmount = pSurplus.Resources.FoodAmount - amountSpent;

					if (pSurplus.Resources.FoodAmount == 0)//remove it for faster processing
					{
						foodSurplusPlanets.splice(s, 1);
						s--;
					}

					if (foodShortageTotal == 0)//we shipped enough food
					{
						shippedAllResources = true;
						break;
					}

				}
			}

			if (!shippedAllResources)
			{
				var foodShortageRatio = foodShortageTotal / (totalPop * 1.0);
				//starvation
				//there is a food shortage ratio chance of loosing one population,
				//if you have 4 pop and 2 food you have a 1 in 2 chance of loosing one
				//otherwise people just slowly starve
				var looseOne = (Astriarch.NextRandom(0, 100) < Math.round(foodShortageRatio * 100));
				if (looseOne)
				{
					var riotReason = ".";//for shortages
					if (player.Resources.GoldAmount <= 0 && foodSurplusPlanets.length != 0)
						riotReason = ", insufficient Gold to ship Food.";
					//notify user of starvation
					planet.PlanetHappiness = Astriarch.Planet.PlanetHappinessType.Riots;
					eotMessages.push(new Astriarch.TurnEventMessage(Astriarch.TurnEventMessage.TurnEventMessageType.FoodShortageRiots, planet, "Riots over food shortages killed one population on planet: " + planet.Name + riotReason));
					if (planet.Population.length > 0)
					{
						planet.Population.pop();
						//don't have to update planet stats based on population here because we'll do it later
					}
				}
				else//reduce the population a bit
				{
					if (planet.Population.length > 0)
					{
						planet.PlanetHappiness = Astriarch.Planet.PlanetHappinessType.Unrest;

						var c = planet.Population[planet.Population.length - 1];//Citizen
						c.PopulationChange -= foodShortageRatio;
						if (c.PopulationChange <= -1.0)
						{
							//notify user of starvation
							eotMessages.push(new Astriarch.TurnEventMessage(Astriarch.TurnEventMessage.TurnEventMessageType.PopulationStarvation, planet, "You lost one population due to food shortages on planet: " + planet.Name));
							planet.Population.pop();
							//don't have to update planet stats based on population here because we'll do it later
						}
						else
						{
							protestingPlanetCount++;

							if (protestingPlanetNames != "")
								protestingPlanetNames += ", ";
							protestingPlanetNames += planet.Name;

							lastProtestingPlanet = planet;
						}
					}
				}

				//have to check to see if we removed the last pop and loose this planet from owned planets if so
				if (planet.Population.length == 0)
				{
					//notify user of planet loss
					eotMessages.push(new Astriarch.TurnEventMessage(Astriarch.TurnEventMessage.TurnEventMessageType.PlanetLostDueToStarvation, planet, "You have lost control of " + planet.Name + " due to starvation"));

					planet.SetPlanetOwner(null);

					//set last known fleet strength
					planet.SetPlayerLastKnownPlanetFleetStrength(player);
				}
			}
		}

		if (protestingPlanetCount > 0)
		{
			var protestingPlanetReason = ".";
			if (player.Resources.GoldAmount <= 0 && foodSurplusPlanets.length != 0)
				protestingPlanetReason = ", insufficient Gold to ship Food.";
			var planetPluralized = "planet: ";
			if (protestingPlanetCount > 1)
				planetPluralized = "planets: ";
			//notify user of population unrest
			eotMessages.push(new Astriarch.TurnEventMessage(Astriarch.TurnEventMessage.TurnEventMessageType.InsufficientFood, lastProtestingPlanet, "Population unrest over lack of Food on " + planetPluralized + protestingPlanetNames + protestingPlanetReason));
		}
							

		if(totalFoodShipped != 0)
			eotMessages.push(new Astriarch.TurnEventMessage(Astriarch.TurnEventMessage.TurnEventMessageType.FoodShipped, null, "You spent " + totalFoodShipped + " Gold shipping Food.")); 

		//TODO: food shortages should further reduce other production, and pop reproduction amt?

		return eotMessages;
	},

	generatePlayerResources: function(/*Player*/ player) {
		//determine tax revenue (gold)
		//for now we generate 1/2 gold for each worker, farmer, or miner
		//TODO: later we may want to allow the user to control taxes vs. research 
		
		var totalWorkers = 0, totalfarmers=0, totalMiners=0;
		for (var i in player.OwnedPlanets)
		{
			var p = player.OwnedPlanets[i];//Planet
			var pop = new Astriarch.Planet.PopulationAssignments();
			p.CountPopulationWorkerTypes(pop);
			totalWorkers += pop.Workers;
			totalfarmers += pop.Farmers;
			totalMiners += pop.Miners;
		}
		
		player.Resources.GoldRemainder += (totalWorkers + totalMiners + totalfarmers) / 2.0;
		player.Resources.AccumulateResourceRemainders();

		//generate planet resources
		for (var i in player.OwnedPlanets)
		{
			player.OwnedPlanets[i].GenerateResources();
		}

	},
	
	addLastStarShipToQueueOnPlanets: function(/*Player*/ player)
	{
		for(var i in player.OwnedPlanets)
		{
			var p = player.OwnedPlanets[i];//Planet
			if (p.BuildLastStarShip && p.BuildQueue.length == 0 && p.StarShipTypeLastBuilt != null)
			{
				//check resources
				var s = new Astriarch.Planet.StarShipInProduction(p.StarShipTypeLastBuilt);

				if (player.Resources.GoldAmount - s.GoldCost > player.LastTurnFoodNeededToBeShipped &&
					player.TotalOreAmount() - s.OreCost >= 0 &&
					player.TotalIridiumAmount() - s.IridiumCost >= 0)
				{
					p.EnqueueProductionItemAndSpendResources(s, player);
				}
			}
		}
	},

	buildPlayerPlanetImprovements: function(/*Player*/ player){//returns List<TurnEventMessage>
		var endOfTurnMessages = []; //List<TurnEventMessage>
		//build planet improvements
		for (var i in player.OwnedPlanets)
		{
			var p = player.OwnedPlanets[i];//Planet
			var buildQueueEmptyObject = {'buildQueueEmpty': false};
			endOfTurnMessages = endOfTurnMessages.concat(p.BuildImprovements(buildQueueEmptyObject));
			if (buildQueueEmptyObject['buildQueueEmpty'])//if the build queue was empty we'll increase gold based on planet production
			{
				if (p.ResourcesPerTurn.ProductionAmountPerTurn > 0)
				{
					player.Resources.GoldRemainder += p.ResourcesPerTurn.ProductionAmountPerTurn / 4.0;
					player.Resources.AccumulateResourceRemainders();
				}
			}
		}
		return endOfTurnMessages;
	},

	growPlayerPlanetPopulation: function(/*Player*/ player){//returns List<TurnEventMessage>
		var endOfTurnMessages = [];// List<TurnEventMessage>
		//population growth rate is based on available space at the planet and the amount currently there
		//as we fill up the planet, growth rate slows
		for (var i in player.OwnedPlanets)
		{
			var p = player.OwnedPlanets[i];//Planet
			var popCount = p.Population.length;
			//check if we can grow
			if (popCount > 0 && p.PlanetHappiness != Astriarch.Planet.PlanetHappinessType.Riots && (popCount < p.MaxPopulation() || p.Population[popCount - 1].PopulationChange < 1.0))
			{
				var growthRatio = popCount / 4.0 * ((p.MaxPopulation() - popCount) / 8.0);
				if (p.PlanetHappiness == Astriarch.Planet.PlanetHappinessType.Unrest)//unrest slows pop growth
					growthRatio = growthRatio / 2.0;
				var lastCitizen = p.Population[popCount - 1];//Citizen
				lastCitizen.PopulationChange += growthRatio;
				if (lastCitizen.PopulationChange >= 1.0)
				{
					//notify user of growth
					endOfTurnMessages.push(new Astriarch.TurnEventMessage(Astriarch.TurnEventMessage.TurnEventMessageType.PopulationGrowth, p, "Population growth on planet: " + p.Name));
					//grow
					lastCitizen.PopulationChange = 0;
					p.Population.push(new Astriarch.Planet.Citizen(p.Type));
					p.ResourcesPerTurn.UpdateResourcesPerTurnBasedOnPlanetStats();
				}
			}
		}

		return endOfTurnMessages;
	},

	checkPlayerDestroyedAndGameOver: function()	{
		var mainPlayerDestroyed = false;

		var destroyedPlayers = [];//List<Player>();
		for (var i in Astriarch.GameModel.Players)
		{
			var player = Astriarch.GameModel.Players[i];//Player
			//a player is destroyed if they have no owned planets and no fleets in transit
			if (Astriarch.CountObjectKeys(player.OwnedPlanets) == 0 && player.FleetsInTransit.length == 0)
			{
				destroyedPlayers.push(player);
				if (player == Astriarch.GameModel.MainPlayer)
					mainPlayerDestroyed = true;
			}
		}

		for (var dpi in destroyedPlayers)
		{
			var destroyedPlayer = destroyedPlayers[dpi];
			for(var i = Astriarch.GameModel.Players.length-1; i >= 0; i--) { 
				if(Astriarch.GameModel.Players[i] == destroyedPlayer) {
					Astriarch.GameModel.Players.splice(i, 1);
				}
			}
		}

		if (Astriarch.GameModel.Players.length > 1 && !mainPlayerDestroyed)
		{
			for (var i in destroyedPlayers)
				Astriarch.GameController.OnPlayerDestroyed(destroyedPlayers[i]);
		}
		else
		{
			Astriarch.GameController.OnPlayerDestroyedGameOver(Astriarch.GameModel.Players[0]);
		}
	},

	CalculateEndGamePoints: function(/*Player*/ player, /*bool*/ playerWon) {
		var points = 0;

		var turnsTaken = Astriarch.GameModel.Turn.Number;
		if (turnsTaken > 1000)//some max, nobody should play this long?
			turnsTaken = 1000;
		
		var totalSystems = Astriarch.GameModel.SystemsToGenerate;
		var planetsPerSystem = Math.floor(Astriarch.GameModel.PlanetsPerSystem);
		var difficultyRating = totalSystems * planetsPerSystem - 8;
		for (var i in Astriarch.GameModel.Players)
		{
			var p = Astriarch.GameModel.Players[i];//Player
			if (p.Type == Astriarch.Player.PlayerType.Computer_Easy)
				difficultyRating += 1;
			else if (p.Type == Astriarch.Player.PlayerType.Computer_Normal)
				difficultyRating += 2;
			else if (p.Type == Astriarch.Player.PlayerType.Computer_Hard)
				difficultyRating += 3;
			else if (p.Type == Astriarch.Player.PlayerType.Computer_Expert)
				difficultyRating += 4;
		}
		//max difficulty right now is 4 * 8 - 8 + 12 = 36
		//min is 1
		var speedFactor = (difficultyRating * 1.0)/(turnsTaken * 1.0);

		var ownedPlanets = Astriarch.CountObjectKeys(player.OwnedPlanets);
		if (ownedPlanets == 0)
			ownedPlanets = 1;//so that we have points for loosers too
		var totalPopulation = player.GetTotalPopulation();
		if (totalPopulation == 0)
			totalPopulation = 1;//so that we have points for loosers too

		points = Math.round((speedFactor * difficultyRating * ownedPlanets) + (totalPopulation * totalSystems));

		return points;
	}
};//Astriarch.GameTools

Astriarch.Util = {
	
	//image data hard-coded here to get around having to draw an image to a canvas in order to change the pixels
	starshipImageData: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,0,0,0,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0],
	spaceplatformImageData: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,128,0,255,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	
	
	ChangeImageColor: function(/*Image bitmap array*/ bmpArr, /*ColorRGBA*/ colorNew)
	{
		var retBmpArr = new Array(bmpArr.length);
		for (var i = 0; i < bmpArr.length; i+=4)
		{
			if (bmpArr[i+3] != 0)//if the pixel is non-transparent?
			{
				retBmpArr[i+0] = colorNew.r;//red
				retBmpArr[i+1] = colorNew.g;//green
				retBmpArr[i+2] = colorNew.b;//blue
			}
			else//just copy from our source to our return value
			{
				retBmpArr[i+0] = bmpArr[i+0];//red
				retBmpArr[i+1] = bmpArr[i+1];//green
				retBmpArr[i+2] = bmpArr[i+2];//blue
			}
			retBmpArr[i+3] = bmpArr[i+3];//alpha, keep it the same as the source
		}
		
		return retBmpArr;
	}

};//Astriarch.Util

/**
 * A ColorRGBA represents the red green blue and alpha of a color
 * @constructor
 */
Astriarch.Util.ColorRGBA = function(r, g, b, a) {
	this.r = r;//red
	this.g = g;//green
	this.b = b;//blue
	this.a = a;//alpha
};

/**
 * toString converts a ColorRGBA object to a string the canvas can recognize
 * @this {Astriarch.Util.ColorRGBA}
 * @return {string}
 */
Astriarch.Util.ColorRGBA.prototype.toString = function() {
	return 'rgba(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + this.a + ')';
};
